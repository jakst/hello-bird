diff --git a/api/index.ts b/api/index.ts
index 0bf7898fbc144f5d911359a2c5af2f5f6785052e..0a31c000bf57f1872d681b07869f4cb8168367b0 100644
--- a/api/index.ts
+++ b/api/index.ts
@@ -1,43 +1,44 @@
-import { registerApiRoutes } from "./internalFetch";
-import { getRouteMatches } from "./router";
-import { MatchRoute, Method, Route } from "./types";
+// @ts-nocheck
+import { registerApiRoutes } from './internalFetch'
+import { getRouteMatches } from './router'
+import { MatchRoute, Method, Route } from './types'
 
 // the line below will be replaced by the compiler with a configuration of routes
 // based on the files in src/routes
 // we have to declare this with `var` so that we can find it even if vite precompiles the code
 // @ts-ignore
-var api = $API_ROUTES;
+var api = $API_ROUTES
 
 // `delete` is a reserved word in JS, so we use `del` instead
 
 function routeToMatchRoute(route: Route): MatchRoute {
-  const segments = route.path.split("/").filter(Boolean);
+  const segments = route.path.split('/').filter(Boolean)
 
-  const params: { type: "*" | ":"; name: string; index: number }[] = [];
-  const matchSegments: (string | null)[] = [];
-  let score = route.path.endsWith("/") ? 4 : 0;
-  let wildcard = false;
+  const params: { type: '*' | ':'; name: string; index: number }[] = []
+  const matchSegments: (string | null)[] = []
+  let score = route.path.endsWith('/') ? 4 : 0
+  let wildcard = false
 
   for (const [index, segment] of segments.entries()) {
-    if (segment[0] === ":") {
-      const name = segment.slice(1);
-      score += 3;
+    if (segment[0] === ':') {
+      const name = segment.slice(1)
+      score += 3
       params.push({
-        type: ":",
+        type: ':',
         name,
-        index
-      });
-      matchSegments.push(null);
-    } else if (segment[0] === "*") {
+        index,
+      })
+      matchSegments.push(null)
+    } else if (segment[0] === '*') {
       params.push({
-        type: "*",
+        type: '*',
         name: segment.slice(1),
-        index
-      });
-      wildcard = true;
+        index,
+      })
+      wildcard = true
     } else {
-      score += 4;
-      matchSegments.push(segment);
+      score += 4
+      matchSegments.push(segment)
     }
   }
 
@@ -46,22 +47,28 @@ function routeToMatchRoute(route: Route): MatchRoute {
     score,
     params,
     matchSegments,
-    wildcard
-  };
+    wildcard,
+  }
 }
 
-const allRoutes = (api as Route[]).map(routeToMatchRoute).sort((a, b) => b.score - a.score);
+const allRoutes = (api as Route[])
+  .map(routeToMatchRoute)
+  .sort((a, b) => b.score - a.score)
 
-registerApiRoutes(allRoutes);
+registerApiRoutes(allRoutes)
 
 export function getApiHandler(url: URL, method: string) {
-  return getRouteMatches(allRoutes, url.pathname, method.toUpperCase() as Method);
+  return getRouteMatches(
+    allRoutes,
+    url.pathname,
+    method.toUpperCase() as Method
+  )
 }
 
 export function isApiRequest(request: Request) {
-  let apiHandler = getApiHandler(new URL(request.url), request.method);
-  return Boolean(apiHandler);
+  let apiHandler = getApiHandler(new URL(request.url), request.method)
+  return Boolean(apiHandler)
 }
 
-export * from "../server/responses";
-export type { APIEvent } from "./types";
+export * from '../server/responses'
+export type { APIEvent } from './types'
diff --git a/api/internalFetch.ts b/api/internalFetch.ts
index b8f2951f38efae4f9c65a6d0f198dc0549ad107c..820b865a3a7d619c9dbfd5d0bb9ca1b4c190cb52 100644
--- a/api/internalFetch.ts
+++ b/api/internalFetch.ts
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import { FETCH_EVENT } from "../server/types";
 import { getRouteMatches } from "./router";
 import type { APIEvent, MatchRoute, Method } from "./types";
diff --git a/api/middleware.ts b/api/middleware.ts
index b9d01fc82bf52146e9825dee8466001cdc9f12eb..787f8c03f7acac04a61e8415c13f71afee68e005 100644
--- a/api/middleware.ts
+++ b/api/middleware.ts
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import { Middleware } from "../entry-server";
 import { FetchEvent, FETCH_EVENT } from "../server/types";
 import { getApiHandler } from "./index";
diff --git a/api/router.ts b/api/router.ts
index cc4eb7af7f27ef1179c6d5340e1932a44dc48455..cbfdf6a6f006249e4d6614479a97acffc75d51e1 100644
--- a/api/router.ts
+++ b/api/router.ts
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import { MatchRoute, Method } from "./types";
 
 export function getRouteMatches(routes: MatchRoute[], path: string, method: Method) {
diff --git a/api/types.ts b/api/types.ts
index f0b94e2b5cc8d38974008c7570e25d74e9e35e75..a5ddba214f44962d4a5050e36b227a7c9c6e4c52 100644
--- a/api/types.ts
+++ b/api/types.ts
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import { FetchEvent, FETCH_EVENT } from "../server/types";
 
 export interface APIEvent extends FetchEvent {
diff --git a/data/Form.tsx b/data/Form.tsx
index 3f2a5b89fb40f965a3c9d8a50a08b82f225b81a0..874454327e63b23e1046a67afb22e2ca8c8655c4 100644
--- a/data/Form.tsx
+++ b/data/Form.tsx
@@ -1,3 +1,4 @@
+// @ts-nocheck
 /*!
  * Original code by Remix Sofware Inc
  * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details
diff --git a/data/FormError.tsx b/data/FormError.tsx
index f0c79c365f66e40b6b18810033b812cd7ab7ef69..2f34ed17a7edabecce899f154c228644d6fa66d6 100644
--- a/data/FormError.tsx
+++ b/data/FormError.tsx
@@ -1,3 +1,4 @@
+// @ts-nocheck
 export class ServerError extends Error {
   status: number;
   constructor(message: string, { status, stack }: { status?: number; stack?: string } = {}) {
diff --git a/data/createRouteAction.tsx b/data/createRouteAction.tsx
index c9001c5f786298a39844c139df9e5ce3477e49d4..004bac9165b87cb19195dec17691ac25842f57fb 100644
--- a/data/createRouteAction.tsx
+++ b/data/createRouteAction.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { useNavigate, useSearchParams, type Navigator } from "@solidjs/router";
 import { $TRACK, batch, createSignal, useContext } from "solid-js";
 import { FormError, FormImpl, FormProps } from "./Form";
diff --git a/entry-client/StartClient.tsx b/entry-client/StartClient.tsx
index 9cb76d2856c35f02ef994c78d79a06bed4b605a9..c3a38fb2b9c9c357f3f17b313ec115a0b8df067f 100644
--- a/entry-client/StartClient.tsx
+++ b/entry-client/StartClient.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { MetaProvider } from "@solidjs/meta";
 import { Router, RouterProps } from "@solidjs/router";
 import Root from "~start/root";
diff --git a/entry-client/mount.tsx b/entry-client/mount.tsx
index 34df65eba8cf9836d3a91c8596d686d73ed703a2..07e26f22fcabd0bbf97ab85f84695fc7e05ea148 100644
--- a/entry-client/mount.tsx
+++ b/entry-client/mount.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import type { JSX } from "solid-js";
 import { getOwner } from "solid-js";
 import { createComponent, getNextElement, hydrate, render } from "solid-js/web";
diff --git a/entry-server/StartServer.tsx b/entry-server/StartServer.tsx
index fc20600cf12e87874b5ceb65b429cc5ed38c13ac..93851f54d556e0a3d8094af4550f937a284dbf0a 100644
--- a/entry-server/StartServer.tsx
+++ b/entry-server/StartServer.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { MetaProvider } from "@solidjs/meta";
 import { RouteDataFunc, Router, RouterProps } from "@solidjs/router";
 import { ComponentProps, sharedConfig } from "solid-js";
diff --git a/entry-server/render.ts b/entry-server/render.ts
index 6ede4ac9151ecbb32d5777ab9fe9966cc20abfd1..b8f5e471490aa6c02beead00bb0c0e63c8c6c9df 100644
--- a/entry-server/render.ts
+++ b/entry-server/render.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { JSX } from "solid-js";
 import { renderToStream, renderToString, renderToStringAsync } from "solid-js/web";
 import { internalFetch } from "../api/internalFetch";
diff --git a/index.tsx b/index.tsx
index 74f088b550d05a49f1dcd83cf13bf4f9c20e65c6..483814ec47b9864b2fc81c87d8725f9fdb3a9def 100644
--- a/index.tsx
+++ b/index.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 export { Link, Meta, Style, Stylesheet, Title } from "@solidjs/meta";
 export {
   Navigate,
diff --git a/islands/index.tsx b/islands/index.tsx
index 5b8ff205e846d1ebe9e06aeb658ee57c6a9b2da3..74ac4cc8d18f0bac9e121aa4eca3e1b44ff16bc4 100644
--- a/islands/index.tsx
+++ b/islands/index.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { Component, ComponentProps, lazy, splitProps, useContext } from "solid-js";
 import { Hydration, NoHydration } from "solid-js/web";
 import { ServerContext } from "../server/ServerContext";
diff --git a/islands/router.ts b/islands/router.ts
index d9618a5e33141c4f057b5f486453178ca60a6124..1c33a50d93260fbddb76db05e1f8cfb8cbf1796b 100644
--- a/islands/router.ts
+++ b/islands/router.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import type { Location, Navigator } from "@solidjs/router";
 import { createSignal } from "solid-js";
 interface LocationEntry {
diff --git a/islands/server-router.tsx b/islands/server-router.tsx
index a778780bc780061a90560912febfc1026e185d77..02dfb6de9bc2c40cd31e89ec3225c89ce87cd928 100644
--- a/islands/server-router.tsx
+++ b/islands/server-router.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { createContext, JSX, useContext } from "solid-js";
 import { ssr } from "solid-js/web";
 export interface RouteDefinition {
diff --git a/root/Document.tsx b/root/Document.tsx
index 19a9f0a300a62cb1bd4911272bd50875e5693b4e..371169d08060972e142ba984e6b0e66e128d80e6 100644
--- a/root/Document.tsx
+++ b/root/Document.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import type { JSX } from "solid-js";
 import { children, ComponentProps } from "solid-js";
 import { insert, NoHydration, spread, ssrElement } from "solid-js/web";
diff --git a/root/InlineStyles.tsx b/root/InlineStyles.tsx
index d215c4ba57d055a22d872a112bac0ea72343f789..e83511ee7fc1388bfb948d91302bcc8a0cdb20c3 100644
--- a/root/InlineStyles.tsx
+++ b/root/InlineStyles.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { Style } from "@solidjs/meta";
 import { createResource, Show, Suspense, useContext } from "solid-js";
 import type { PageEvent } from "../server";
diff --git a/root/Links.tsx b/root/Links.tsx
index 04708cc2cf4913ddd83c8067fd51c88bc09c6bb7..6fb9c9d1b4d43be07b80977973c03de484378917 100644
--- a/root/Links.tsx
+++ b/root/Links.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { JSXElement, useContext } from "solid-js";
 import { useAssets } from "solid-js/web";
 import { ServerContext } from "../server/ServerContext";
diff --git a/root/Scripts.tsx b/root/Scripts.tsx
index ea6dae40959f4fdb0faff8933879a1797ef15c84..e6e9d750bb9a35121d4d45beb3664ad3a74c1157 100644
--- a/root/Scripts.tsx
+++ b/root/Scripts.tsx
@@ -1,14 +1,16 @@
-import { useContext } from "solid-js";
-import { HydrationScript, isServer, NoHydration } from "solid-js/web";
-import { ServerContext } from "../server/ServerContext";
-import { InlineStyles } from "./InlineStyles";
+// @ts-nocheck
 
-const isDev = import.meta.env.MODE === "development";
-const isSSR = import.meta.env.START_SSR;
-const isIslands = import.meta.env.START_ISLANDS;
+import { useContext } from 'solid-js'
+import { HydrationScript, isServer, NoHydration } from 'solid-js/web'
+import { ServerContext } from '../server/ServerContext'
+import { InlineStyles } from './InlineStyles'
+
+const isDev = import.meta.env.MODE === 'development'
+const isSSR = import.meta.env.START_SSR
+const isIslands = import.meta.env.START_ISLANDS
 
 export default function Scripts() {
-  const context = useContext(ServerContext);
+  const context = useContext(ServerContext)
   return (
     <>
       {isSSR && <HydrationScript />}
@@ -26,23 +28,36 @@ export default function Scripts() {
               <script
                 type="module"
                 async
-                src={"/@fs/" + import.meta.env.START_ENTRY_CLIENT}
+                src={'/@fs/' + import.meta.env.START_ENTRY_CLIENT}
                 $ServerOnly
               ></script>
             </>
           ) : isSSR ? (
             // @ts-ignore
-            <script type="module" async src={context!.env.manifest["entry-client"][0].href} />
+            <script
+              type="module"
+              async
+              src={context!.env.manifest['entry-client'][0].href}
+            />
           ) : import.meta.env.START_INDEX_HTML ? (
             // used in the SPA build index.html mode to create a reference to index html
             // which will be used by the client build
-            <script type="module" async src={import.meta.env.START_ENTRY_CLIENT} $ServerOnly />
+            <script
+              type="module"
+              async
+              src={import.meta.env.START_ENTRY_CLIENT}
+              $ServerOnly
+            />
           ) : (
             // @ts-ignore
-            <script type="module" async src={context!.env.manifest["index.html"][0].href} />
+            <script
+              type="module"
+              async
+              src={context!.env.manifest['index.html'][0].href}
+            />
           ))}
       </NoHydration>
       {isDev && <InlineStyles />}
     </>
-  );
+  )
 }
diff --git a/router.tsx b/router.tsx
index 56ba9635d9ad97aafd53ec9dbdabb774134df9de..bd94fc188b559bf53a1fd21b4ca6aaf6ebddee1c 100644
--- a/router.tsx
+++ b/router.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import {
   A as BaseA,
   Location,
diff --git a/server/ServerContext.tsx b/server/ServerContext.tsx
index 006547d06ec1ee197d1a7dc282f30b473d5a7252..a9985d0e1f3befcfee9cf926cdd517f0751c8d7c 100644
--- a/server/ServerContext.tsx
+++ b/server/ServerContext.tsx
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { PageEvent } from "./types";
 
 import { createContext, useContext } from "solid-js";
diff --git a/server/middleware.ts b/server/middleware.ts
index 3384200fc57b23c85c2a771df7220e724d99d28b..91f8b76fb095eeeebe396338570b35b2cb4ee914 100644
--- a/server/middleware.ts
+++ b/server/middleware.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { internalFetch } from "../api/internalFetch";
 import { Middleware as ServerMiddleware } from "../entry-server/StartServer";
 import { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from "./responses";
diff --git a/server/responses.ts b/server/responses.ts
index 194cb45de063007a9c5a7ba942359d586542d953..03f2eaa641aa6c6b00e257a827d3a296c1c7cf24 100644
--- a/server/responses.ts
+++ b/server/responses.ts
@@ -1,66 +1,74 @@
-export const XSolidStartStatusCodeHeader = "x-solidstart-status-code";
-export const XSolidStartLocationHeader = "x-solidstart-location";
-export const LocationHeader = "Location";
-export const ContentTypeHeader = "content-type";
-export const XSolidStartResponseTypeHeader = "x-solidstart-response-type";
-export const XSolidStartContentTypeHeader = "x-solidstart-content-type";
-export const XSolidStartOrigin = "x-solidstart-origin";
-export const JSONResponseType = "application/json";
+// @ts-nocheck
+
+export const XSolidStartStatusCodeHeader = 'x-solidstart-status-code'
+export const XSolidStartLocationHeader = 'x-solidstart-location'
+export const LocationHeader = 'Location'
+export const ContentTypeHeader = 'content-type'
+export const XSolidStartResponseTypeHeader = 'x-solidstart-response-type'
+export const XSolidStartContentTypeHeader = 'x-solidstart-content-type'
+export const XSolidStartOrigin = 'x-solidstart-origin'
+export const JSONResponseType = 'application/json'
 
 /**
  * A JSON response. Converts `data` to JSON and sets the `Content-Type` header.
  */
-export function json<Data>(data: Data, init: number | ResponseInit = {}): Response {
-  let responseInit: any = init;
-  if (typeof init === "number") {
-    responseInit = { status: init };
+export function json<Data>(
+  data: Data,
+  init: number | ResponseInit = {}
+): Response {
+  let responseInit: any = init
+  if (typeof init === 'number') {
+    responseInit = { status: init }
   }
 
-  let headers = new Headers(responseInit.headers);
+  let headers = new Headers(responseInit.headers)
 
   if (!headers.has(ContentTypeHeader)) {
-    headers.set(ContentTypeHeader, "application/json; charset=utf-8");
+    headers.set(ContentTypeHeader, 'application/json; charset=utf-8')
   }
 
   const response = new Response(JSON.stringify(data), {
     ...responseInit,
-    headers
-  });
+    headers,
+  })
 
-  return response;
+  return response
 }
 
 /**
  * A redirect response. Sets the status code and the `Location` header.
  * Defaults to "302 Found".
  */
-export function redirect(url: string, init: number | ResponseInit = 302): Response {
-  let responseInit = init;
-  if (typeof responseInit === "number") {
-    responseInit = { status: responseInit };
-  } else if (typeof responseInit.status === "undefined") {
-    responseInit.status = 302;
+export function redirect(
+  url: string,
+  init: number | ResponseInit = 302
+): Response {
+  let responseInit = init
+  if (typeof responseInit === 'number') {
+    responseInit = { status: responseInit }
+  } else if (typeof responseInit.status === 'undefined') {
+    responseInit.status = 302
   }
 
-  if (url === "") {
-    url = "/";
+  if (url === '') {
+    url = '/'
   }
 
-  if (process.env.NODE_ENV === "development") {
-    if (url.startsWith(".")) {
-      throw new Error("Relative URLs are not allowed in redirect");
+  if (process.env.NODE_ENV === 'development') {
+    if (url.startsWith('.')) {
+      throw new Error('Relative URLs are not allowed in redirect')
     }
   }
 
-  let headers = new Headers(responseInit.headers);
-  headers.set(LocationHeader, url);
+  let headers = new Headers(responseInit.headers)
+  headers.set(LocationHeader, url)
 
   const response = new Response(null, {
     ...responseInit,
-    headers: headers
-  });
+    headers: headers,
+  })
 
-  return response;
+  return response
 }
 
 export function eventStream(
@@ -69,99 +77,105 @@ export function eventStream(
 ) {
   let stream = new ReadableStream({
     start(controller) {
-      let encoder = new TextEncoder();
+      let encoder = new TextEncoder()
       let send = (event: string, data: any) => {
-        controller.enqueue(encoder.encode("event: " + event + "\n"));
-        controller.enqueue(encoder.encode("data: " + data + "\n" + "\n"));
-      };
-      let cleanup = init(send);
-      let closed = false;
+        controller.enqueue(encoder.encode('event: ' + event + '\n'))
+        controller.enqueue(encoder.encode('data: ' + data + '\n' + '\n'))
+      }
+      let cleanup = init(send)
+      let closed = false
       let close = () => {
-        if (closed) return;
-        cleanup();
-        closed = true;
-        request.signal.removeEventListener("abort", close);
-        controller.close();
-      };
-      request.signal.addEventListener("abort", close);
+        if (closed) return
+        cleanup()
+        closed = true
+        request.signal.removeEventListener('abort', close)
+        controller.close()
+      }
+      request.signal.addEventListener('abort', close)
       if (request.signal.aborted) {
-        close();
-        return;
+        close()
+        return
       }
-    }
-  });
+    },
+  })
   return new Response(stream, {
-    headers: { "Content-Type": "text/event-stream" }
-  });
+    headers: { 'Content-Type': 'text/event-stream' },
+  })
 }
 
 export function isResponse(value: any): value is Response {
   return (
     value != null &&
-    typeof value.status === "number" &&
-    typeof value.statusText === "string" &&
-    typeof value.headers === "object" &&
-    typeof value.body !== "undefined"
-  );
+    typeof value.status === 'number' &&
+    typeof value.statusText === 'string' &&
+    typeof value.headers === 'object' &&
+    typeof value.body !== 'undefined'
+  )
 }
 
-const redirectStatusCodes = new Set([204, 301, 302, 303, 307, 308]);
+const redirectStatusCodes = new Set([204, 301, 302, 303, 307, 308])
 
-export function isRedirectResponse(response: Response | any): response is Response {
-  return response && response instanceof Response && redirectStatusCodes.has(response.status);
+export function isRedirectResponse(
+  response: Response | any
+): response is Response {
+  return (
+    response &&
+    response instanceof Response &&
+    redirectStatusCodes.has(response.status)
+  )
 }
 
 export class ResponseError extends Error implements Response {
-  status: number;
-  headers: Headers;
-  name = "ResponseError";
-  ok: boolean;
-  statusText: string;
-  redirected: boolean;
-  url: string;
+  status: number
+  headers: Headers
+  name = 'ResponseError'
+  ok: boolean
+  statusText: string
+  redirected: boolean
+  url: string
   constructor(response: Response) {
     let message = JSON.stringify({
-      $type: "response",
+      $type: 'response',
       status: response.status,
       message: response.statusText,
-      headers: [...response.headers.entries()]
-    });
-    super(message);
-    this.status = response.status;
-    this.headers = new Map([...response.headers.entries()]) as any as Headers;
-    this.url = response.url;
-    this.ok = response.ok;
-    this.statusText = response.statusText;
-    this.redirected = response.redirected;
-    this.bodyUsed = false;
-    this.type = response.type;
-    this.response = () => response;
+      headers: [...response.headers.entries()],
+    })
+    super(message)
+    this.status = response.status
+    this.headers = new Map([...response.headers.entries()]) as any as Headers
+    this.url = response.url
+    this.ok = response.ok
+    this.statusText = response.statusText
+    this.redirected = response.redirected
+    this.bodyUsed = false
+    this.type = response.type
+    this.response = () => response
   }
 
-  response: () => Response;
-  type: ResponseType;
+  response: () => Response
+  type: ResponseType
   clone(): Response {
-    return this.response();
+    return this.response()
   }
   get body(): ReadableStream<Uint8Array> {
-    return this.response().body!;
+    return this.response().body!
   }
-  bodyUsed: boolean;
+  bodyUsed: boolean
   async arrayBuffer(): Promise<ArrayBuffer> {
-    return await this.response().arrayBuffer();
+    return await this.response().arrayBuffer()
   }
   async blob(): Promise<Blob> {
-    return await this.response().blob();
+    return await this.response().blob()
   }
   async formData(): Promise<FormData> {
-    return await this.response().formData();
+    return await this.response().formData()
   }
 
   async text() {
-    return await this.response().text();
+    return await this.response().text()
   }
 
   async json() {
-    return await this.response().json();
+    return await this.response().json()
   }
 }
diff --git a/server/server-functions/server.ts b/server/server-functions/server.ts
index eee050432cbf8c98e1732b02580ba9e71c515727..2cb1448b4088d9969428a35a3305d1c976cbecb9 100644
--- a/server/server-functions/server.ts
+++ b/server/server-functions/server.ts
@@ -1,7 +1,9 @@
-import { sharedConfig } from "solid-js";
-import { internalFetch } from "../../api/internalFetch";
-import { FormError } from "../../data";
-import { ServerError } from "../../data/FormError";
+// @ts-nocheck
+
+import { sharedConfig } from 'solid-js'
+import { internalFetch } from '../../api/internalFetch'
+import { FormError } from '../../data'
+import { ServerError } from '../../data/FormError'
 import {
   ContentTypeHeader,
   isRedirectResponse,
@@ -11,93 +13,98 @@ import {
   XSolidStartContentTypeHeader,
   XSolidStartLocationHeader,
   XSolidStartOrigin,
-  XSolidStartResponseTypeHeader
-} from "../responses";
-import { PageEvent, ServerFunctionEvent } from "../types";
-import { CreateServerFunction } from "./types";
-export type { APIEvent } from "../../api/types";
+  XSolidStartResponseTypeHeader,
+} from '../responses'
+import { PageEvent, ServerFunctionEvent } from '../types'
+import { CreateServerFunction } from './types'
+export type { APIEvent } from '../../api/types'
 
 export const server$: CreateServerFunction = ((_fn: any) => {
-  throw new Error("Should be compiled away");
-}) as unknown as CreateServerFunction;
+  throw new Error('Should be compiled away')
+}) as unknown as CreateServerFunction
 
 async function parseRequest(event: ServerFunctionEvent) {
-  let request = event.request;
-  let contentType = request.headers.get(ContentTypeHeader);
+  let request = event.request
+  let contentType = request.headers.get(ContentTypeHeader)
   let name = new URL(request.url).pathname,
-    args = [];
+    args = []
 
   if (contentType) {
     if (contentType === JSONResponseType) {
-      let text = await request.text();
+      let text = await request.text()
       try {
         args = JSON.parse(text, (key: string, value: any) => {
           if (!value) {
-            return value;
+            return value
           }
-          if (value.$type === "fetch_event") {
-            return event;
+          if (value.$type === 'fetch_event') {
+            return event
           }
-          if (value.$type === "headers") {
-            let headers = new Headers();
-            request.headers.forEach((value, key) => headers.set(key, value));
-            value.values.forEach(([key, value]: [string, any]) => headers.set(key, value));
-            return headers;
+          if (value.$type === 'headers') {
+            let headers = new Headers()
+            request.headers.forEach((value, key) => headers.set(key, value))
+            value.values.forEach(([key, value]: [string, any]) =>
+              headers.set(key, value)
+            )
+            return headers
           }
-          if (value.$type === "request") {
+          if (value.$type === 'request') {
             return new Request(value.url, {
               method: value.method,
-              headers: value.headers
-            });
+              headers: value.headers,
+            })
           }
-          return value;
-        });
+          return value
+        })
       } catch (e) {
-        throw new Error(`Error parsing request body: ${text}`);
+        throw new Error(`Error parsing request body: ${text}`)
       }
-    } else if (contentType.includes("form")) {
-      let formData = await request.clone().formData();
-      args = [formData, event];
+    } else if (contentType.includes('form')) {
+      let formData = await request.clone().formData()
+      args = [formData, event]
     }
   }
-  return [name, args] as const;
+  return [name, args] as const
 }
 
 export function respondWith(
   request: Request,
   data: Response | Error | FormError | string | object,
-  responseType: "throw" | "return"
+  responseType: 'throw' | 'return'
 ) {
   if (data instanceof ResponseError) {
-    data = data.clone();
+    data = data.clone()
   }
 
   if (data instanceof Response) {
-    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === "client") {
-      let headers = new Headers(data.headers);
-      headers.set(XSolidStartOrigin, "server");
-      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader)!);
-      headers.set(XSolidStartResponseTypeHeader, responseType);
-      headers.set(XSolidStartContentTypeHeader, "response");
+    if (
+      isRedirectResponse(data) &&
+      request.headers.get(XSolidStartOrigin) === 'client'
+    ) {
+      let headers = new Headers(data.headers)
+      headers.set(XSolidStartOrigin, 'server')
+      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader)!)
+      headers.set(XSolidStartResponseTypeHeader, responseType)
+      headers.set(XSolidStartContentTypeHeader, 'response')
       return new Response(null, {
         status: 204,
-        statusText: "Redirected",
-        headers: headers
-      });
+        statusText: 'Redirected',
+        headers: headers,
+      })
     } else if (data.status === 101) {
       // this is a websocket upgrade, so we don't want to modify the response
-      return data;
+      return data
     } else {
-      let headers = new Headers(data.headers);
-      headers.set(XSolidStartOrigin, "server");
-      headers.set(XSolidStartResponseTypeHeader, responseType);
-      headers.set(XSolidStartContentTypeHeader, "response");
+      let headers = new Headers(data.headers)
+      headers.set(XSolidStartOrigin, 'server')
+      headers.set(XSolidStartResponseTypeHeader, responseType)
+      headers.set(XSolidStartContentTypeHeader, 'response')
 
       return new Response(data.body, {
         status: data.status,
         statusText: data.statusText,
-        headers
-      });
+        headers,
+      })
     }
   } else if (data instanceof FormError) {
     return new Response(
@@ -106,20 +113,20 @@ export function respondWith(
           message: data.message,
           stack: import.meta.env.DEV
             ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}`
-            : "",
+            : '',
           formError: data.formError,
           fields: data.fields,
-          fieldErrors: data.fieldErrors
-        }
+          fieldErrors: data.fieldErrors,
+        },
       }),
       {
         status: 400,
         headers: {
           [XSolidStartResponseTypeHeader]: responseType,
-          [XSolidStartContentTypeHeader]: "form-error"
-        }
+          [XSolidStartContentTypeHeader]: 'form-error',
+        },
       }
-    );
+    )
   } else if (data instanceof ServerError) {
     return new Response(
       JSON.stringify({
@@ -127,89 +134,92 @@ export function respondWith(
           message: data.message,
           stack: import.meta.env.DEV
             ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}`
-            : ""
-        }
+            : '',
+        },
       }),
       {
         status: data.status,
         headers: {
           [XSolidStartResponseTypeHeader]: responseType,
-          [XSolidStartContentTypeHeader]: "server-error"
-        }
+          [XSolidStartContentTypeHeader]: 'server-error',
+        },
       }
-    );
+    )
   } else if (data instanceof Error) {
-    console.error(data);
+    console.error(data)
     return new Response(
       JSON.stringify({
         error: {
           message: import.meta.env.DEV
             ? `Internal Server Error (${data.message})`
-            : "Internal Server Error",
+            : 'Internal Server Error',
           stack: import.meta.env.DEV
             ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \n\n${data.stack}`
-            : "",
-          status: (data as any).status
-        }
+            : '',
+          status: (data as any).status,
+        },
       }),
       {
         status: (data as any).status || 500,
         headers: {
           [XSolidStartResponseTypeHeader]: responseType,
-          [XSolidStartContentTypeHeader]: "error"
-        }
+          [XSolidStartContentTypeHeader]: 'error',
+        },
       }
-    );
+    )
   } else if (
-    typeof data === "object" ||
-    typeof data === "string" ||
-    typeof data === "number" ||
-    typeof data === "boolean"
+    typeof data === 'object' ||
+    typeof data === 'string' ||
+    typeof data === 'number' ||
+    typeof data === 'boolean'
   ) {
     return new Response(JSON.stringify(data), {
       status: 200,
       headers: {
-        [ContentTypeHeader]: "application/json",
+        [ContentTypeHeader]: 'application/json',
         [XSolidStartResponseTypeHeader]: responseType,
-        [XSolidStartContentTypeHeader]: "json"
-      }
-    });
+        [XSolidStartContentTypeHeader]: 'json',
+      },
+    })
   }
 
-  return new Response("null", {
+  return new Response('null', {
     status: 200,
     headers: {
-      [ContentTypeHeader]: "application/json",
-      [XSolidStartContentTypeHeader]: "json",
-      [XSolidStartResponseTypeHeader]: responseType
-    }
-  });
+      [ContentTypeHeader]: 'application/json',
+      [XSolidStartContentTypeHeader]: 'json',
+      [XSolidStartResponseTypeHeader]: responseType,
+    },
+  })
 }
 
 export async function handleServerRequest(event: ServerFunctionEvent) {
-  const url = new URL(event.request.url);
+  const url = new URL(event.request.url)
 
   if (server$.hasHandler(url.pathname)) {
     try {
-      let [name, args] = await parseRequest(event);
-      let handler = server$.getHandler(name);
+      let [name, args] = await parseRequest(event)
+      let handler = server$.getHandler(name)
       if (!handler) {
         throw {
           status: 404,
-          message: "Handler Not Found for " + name
-        };
+          message: 'Handler Not Found for ' + name,
+        }
       }
-      const data = await handler.call(event, ...(Array.isArray(args) ? args : [args]));
-      return respondWith(event.request, data, "return");
+      const data = await handler.call(
+        event,
+        ...(Array.isArray(args) ? args : [args])
+      )
+      return respondWith(event.request, data, 'return')
     } catch (error) {
-      return respondWith(event.request, error as Error, "throw");
+      return respondWith(event.request, error as Error, 'throw')
     }
   }
 
-  return null;
+  return null
 }
 
-const handlers = new Map();
+const handlers = new Map()
 // server$.requestContext = null;
 server$.createHandler = (_fn, hash) => {
   // this is run in two ways:
@@ -222,67 +232,67 @@ server$.createHandler = (_fn, hash) => {
   // - request is parsed to figure out the args that need to be passed here, we still pass the same args as above, but they are not the same reference
   //   as the ones passed in the client. They are cloned and serialized and made as similar to the ones passed in the client as possible
   let fn: any = function (this: PageEvent | any, ...args: any[]) {
-    let ctx: any | undefined;
+    let ctx: any | undefined
 
     // if called with fn.call(...), we check if we got a valid RequestContext, and use that as
     // the request context for this server function call
-    if (typeof this === "object") {
-      ctx = this;
+    if (typeof this === 'object') {
+      ctx = this
       // @ts-ignore
     } else if (sharedConfig.context && sharedConfig.context.requestContext) {
       // otherwise we check if the sharedConfig has a requestContext, and use that as the request context
       // people shouldn't rely on this
       // @ts-ignore
-      ctx = sharedConfig.context.requestContext;
+      ctx = sharedConfig.context.requestContext
     } else {
       // this is normally used during a test
       ctx = {
-        request: new URL(hash, "http://localhost:3000").href,
-        responseHeaders: new Headers()
-      } as any;
+        request: new URL(hash, 'http://localhost:3000').href,
+        responseHeaders: new Headers(),
+      } as any
     }
 
     const execute = async () => {
       try {
-        let e = await _fn.call(ctx, ...args);
-        return e;
+        let e = await _fn.call(ctx, ...args)
+        return e
       } catch (e) {
         if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {
           const error = new Error(
             e.message +
-              "\n" +
-              " You probably are using a variable defined in a closure in your server function."
-          );
-          error.stack = e.stack;
-          throw error;
+              '\n' +
+              ' You probably are using a variable defined in a closure in your server function.'
+          )
+          error.stack = e.stack
+          throw error
         }
-        throw e;
+        throw e
       }
-    };
+    }
 
-    return execute();
-  };
+    return execute()
+  }
 
-  fn.url = hash;
+  fn.url = hash
   fn.action = function (...args: any[]) {
-    return fn.call(this, ...args);
-  };
+    return fn.call(this, ...args)
+  }
 
-  return fn;
-};
+  return fn
+}
 
 server$.registerHandler = function (route, handler) {
-  handlers.set(route, handler);
-};
+  handlers.set(route, handler)
+}
 
 server$.getHandler = function (route) {
-  return handlers.get(route);
-};
+  return handlers.get(route)
+}
 
 server$.hasHandler = function (route) {
-  return handlers.has(route);
-};
+  return handlers.has(route)
+}
 
 // used to fetch from an API route on the server or client, without falling into
 // fetch problems on the server
-server$.fetch = internalFetch;
+server$.fetch = internalFetch
diff --git a/server/server-functions/types.ts b/server/server-functions/types.ts
index 507e529b138df343d2d9ddf54e18ec565d314233..3920b37bd9516d9afc749949d66697dc26fc8eab 100644
--- a/server/server-functions/types.ts
+++ b/server/server-functions/types.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import { FetchEvent } from "../types";
 
 export type ServerFunction<E extends any[], T extends (...args: [...E]) => void> = ((
diff --git a/session/cookie.ts b/session/cookie.ts
index aca73114f9608471748c6871ad65f2aff8d07fe3..ccd6ca2a27b1fd671a69d9871ab4cf5b2f1b36f3 100644
--- a/session/cookie.ts
+++ b/session/cookie.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 /*!
  * cookie
  * Copyright(c) 2012-2014 Roman Shtylman
diff --git a/session/cookies.ts b/session/cookies.ts
index bfde0bb156e909595bebd86f267e78ba4a8b1fc6..e439d9df1fc39d2bc88299572e0375de9e492f31 100644
--- a/session/cookies.ts
+++ b/session/cookies.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 /*!
  * Original code by Remix Sofware Inc
  * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details
diff --git a/session/memoryStorage.ts b/session/memoryStorage.ts
index fac4ebeff7fea9a3b61e2c4600e01e0e7f33a866..d0cdd5ee7ff4df7f46d53e20ca11badc6625deda 100644
--- a/session/memoryStorage.ts
+++ b/session/memoryStorage.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 /*!
  * Original code by Remix Sofware Inc
  * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details
diff --git a/types.ts b/types.ts
index 792b8b353f653ea1ac18b56db11fbc62f1f49ba5..80b12020c7c91e8697a10d1f01bc1387aa053310 100644
--- a/types.ts
+++ b/types.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 import type { Debugger } from "debug";
 import type { Component } from "solid-js";
 
